/**
 * @StaunStender Function Library
 *
 * You can invoke any function in this library on any page in a MooD solution.
 * Use theese functions to extend the functionality of MooD.
 *
 * @desc - Description of function
 * @param - The parameter (typically a class name generated by MooD) that you inject into the function to get the desired element.
 * @returns - What the function returns
 * @example - Example of input / output of invoking function
 *
 * Standards using the library:
 *
 * 1) Interactive elements (buttons, textfields etc.) should be hidden by default using css.
 * 2) Use a <style> tag to set CSS properties of an interactive element to hidden in the top of your script.
 * 3) Save state variables and DOM elements to variables in the beginning of your functions using getter methods from the library.
 * 4) Manipulate those variables in the function logic - this increases readability and makes it easier to debug.
 * 5) Call variable names something meaningfull - comments to code are welcome, but should not be nessesary.
 * 6) Do not invoke functions in the library file. You only invoke functions from the library on pages locally.
 */

/******************** GETTER FUNCTIONS *************************/

/**
 * @desc - Get a HTML element from the DOM
 * @param {String} - Class name of the element
 * @returns {HTML} - The HTML element
 */
function ssGetElement(className) {
  if (ssElementExists(className)) {
    return document.querySelector(".mood-node-name-" + className);
  }
  return null;
}

/**
 * @desc - Get a collection of HTML element from the DOM
 * @param {String} - Class name of the elements
 * @returns {Array} - An array of matching HTML elements
 */
function ssGetAllElements(className) {
  if (ssElementExists(className)) {
    return document.querySelectorAll(".mood-node-name-" + className);
  }
  return null;
}

/**
 * @desc - Get an element from the DOM not injected by MooD or one that doesn't have mood-node-name-class-name as it's class name
 * @param {String} - Class name of the element
 * @returns {HTLM} - The HTML element
 */
function ssGetNonMoodElement(className) {
  if (ssNoneMoodElementExists(className)) {
    return document.querySelector("." + className);
  }
  return null;
}

/**
 * @desc - Get the value of the text wrapped by an HTML element (what is visible to the user)
 * @param {String} - Name of the element
 * @returns {String} - The innerText of the element (what is visible to the user)
 */
function ssGetInnerText(className) {
  if (ssElementExists(className)) {
    return document
      .querySelector(".mood-node-name-" + className)
      .innerText.trim();
  }
  return null;
}

/**
 * @desc - Get the length of a text in an element as number of characters. Can be used to evaluate if an element is empty.
 * @param {String} - Name of the element
 * @returns {String} - Length of the innerText of the element (number of characters)
 */
function ssGetInnerTextLength(className) {
  if (ssElementExists(className)) {
    return document
      .querySelector(".mood-node-name-" + className)
      .innerText.trim().length;
  }
  return null;
}

/**
 * @desc - Get the textContent property of an element. Sometomes MooD doesn't set text as innerText, but instead with the textContent property. In that case, use this function.
 * @param {String} - Name of the element
 * @returns {String} - The textContent property of an element
 */
function ssGetTextContent(className) {
  if (ssElementExists(className)) {
    return document
      .querySelector(".mood-node-name-" + className)
      .textContent.trim();
  }
  return null;
}

/**
 * @desc - Select the value of a single select drodown
 * @param {String} name - name of the element
 * @returns {String} - value of the select dropdpown
 */
function ssSingleSelectValue(name) {
  if (!$(".mood-node-name-" + name).length > 0) return "";
  var text = $(".mood-node-name-" + name)[0].innerText;
  if (text == "Select...") return "";
  else return text;
}

/**
 * @desc - Get the value of a mood text area element
 * @param {String} name - name of the textarea
 * @returns {String} - value of the text area
 */
function ssTextAreaValue(name) {
  if ($(".mood-node-name-" + name + " textarea").length > 0)
    return $(".mood-node-name-" + name + " textarea").val();
  return 0;
}

/**
 * @desc - Get the value of a mood text editor element
 * @param {String} name - name of the texteditor
 * @returns {String} - value of the texteditor
 */
function ssTexteditorValue(name) {
  return ssDropdownValue(name);
}

/**
 * @desc - Get the value of a mood calendar element
 * @param {String} name - name of the calendar
 * @returns {String} - value of the calendar
 */
function ssCalendarValue(name) {
  return ssDropdownValue(name);
}

/**
 * @desc - Get the value of a mood dropdown element
 * @param {String} name - name of the dropdown element
 * @returns {String} - value of the dropdown
 */
function ssDropdownValue(name) {
  if (
    $(".mood-node-name-" + name + " input").length > 0 &&
    $(".mood-node-name-" + name + " input")[0].value
  )
    return $(".mood-node-name-" + name + " input")[0].value.trim();
  else return 0;
}

/**
 * @desc - Get the value of a selected radiobutton element
 * @param {String} name - name of the radiobutton element
 * @returns {String} - value of the selected radiobutton
 */
function ssRadiobuttons(name) {
  return $(
    ".mood-node-name-" + name + " .dx-list-item-selected .list-item-text"
  )
    .text()
    .trim();
}

/**
 * @desc - Get the numberof radiobuttons selected in a radiobutton element
 * @param {String} name - name of the radiobutton element
 * @returns {Integer} - Number og selected radiobuttons
 */
function ssRadiobuttonsCount(name) {
  if (ssElementExists(name))
    return $(".mood-node-name-" + name + " .dx-list-item").length;
  return 0;
}

/**
 * @desc - Get the html of a selected element
 * @param {String} name - name of the element
 * @returns {HTML} - Inner-html of a selected element. Returns undefined on missing element, no errors.
 */
function ssHtmlValue(name) {
  return $(".mood-node-name-" + name).html();
}

/**
 * @desc - Get the html of a selected element
 * @param {String} name - name of the element
 * @returns {HTML} - Inner-html of a selected element. Returns undefined on missing element, no errors.
 */
function ssReturnDollarNodeName(name) {
  return $(".mood-node-name-" + name);
}

/**
 * @desc - Needs description
 * @param {String} name
 * @returns {HTML} - Needs return value description
 */
function ssReturnDollarAndText(text) {
  return $(text);
}

/**
 * @desc - Get the url a given element links to
 * @param {String} name
 * @returns {HTML} - The href attribute of an element as an url adrress
 */
function ssReturnHrefLink(text, link) {
  return $(text).attr("href", link); //The link taken as a parameter has to be defined as a var first
}

/**
 * @desc - Get the innerHTML of an element
 * @param {String} - Name of the element
 * @returns {HTML/String} - The innerHTML of an element as a String
 */
function ssGetHTML(className) {
  if (ssElementExists(className)) {
    return document.querySelector(".mood-node-name-" + className).innerHTML;
  }
  return null;
}

/**
 * @desc - Get the value of a MooD generated infopanel
 * @param {String} - Name of the element
 * @returns {String} - Name in the infopanel
 */
function ssInfopanelValue(name) {
  if ($(".mood-node-name-" + name).length > 0)
    return $(".mood-node-name-" + name)
      .text()
      .trim();
  return 0;
}

/**
 * @desc - Get a tab as an HTML element
 * @param {String} - Name of the tab
 * @returns {HTML} - The HTML of the Tab
 */
function ssGetTab(className) {
  return Array.from(document.querySelectorAll("li")).find(
    (el) => el.textContent === className
  );
}

/**
 * @desc - Due to difference in environments, this is a custom implementation of ssAddCountOfMyActions for IT Landscape. This implementation should be used if you are handling a menu with multiple tabs of the same name. Get a tab as an HTML element
 * @param {String} - Name of the tab
 * @returns {HTML} - The HTML of the Tab
 */
function ssGetTabItLandscape(className) {
  return Array.from(document.querySelectorAll("li")).filter(
    (el) => el.textContent === className
  );
}

/**
 * @desc - Get all element of a given tag
 * @param {String} - The tag e.g. p, h1 or img
 * @returns {HTML} - The HTML of all the tags
 */
function ssGetElementsByTagName(tag) {
  return document.getElementsByTagName(tag);
}

/**
 * @desc - Check if any of selected values of radiobuttons are == value
 * @param {String} - Value to be checked example "Yes". Mood chosen classname of selected radiobuttons example "dx-list-item-selected"
 * @returns {Boolean} - If value exists in radio buttons
 */
function ssCheckRadioButtonValues(value, className, index) {
  var radioButtons = document.getElementsByClassName(className);
  for (i = index; i < radioButtons.length; i++) {
    if (radioButtons[i].innerText == value) {
      return true;
    }
  }
  return false;
}

/**
 * @desc -  Checks if an inut field is a certain length of characters
 * @param {String} className - Name of the element
 * @param {String} childtag - The tag the input is wrapped in
 * @param {Int} length - Length of characters to check for
 * @returns {Boolean} True if specified length of the input text field equeals the input length given in the paramenter
 */
function ssValidateInputLength(className, childtag, length) {
  if (ssElementExists(className)) {
    var childnode = document
      .getElementsByClassName("mood-node-name-" + className)[0]
      .getElementsByTagName(childtag)[0];
    var childnodeLength = childnode.value.length;
    if (childnodeLength == length) {
      return true;
    } else {
      return false;
    }
  } else {
    return null;
  }
}

/**
 * @desc - Get the value attribute of an element with text input
 * @param {String} className - Name of the element
 * @returns
 */
function ssGetValueAttribute(className) {
  if (ssElementExists(className)) {
    return document.querySelector(".mood-node-name-" + className + " input")
      .value;
  } else {
    return null;
  }
}

/**
 * @desc - Get the value (title attribute) of an element selected using the Multi Select Dropdown
 * @param {String} className - Name of the element
 * @returns {String} - The selected value of the dropdown
 */
function ssGetValueFromMultiSelectDropdown(className) {
  if (ssElementExists(className)) {
    return ssGetElement(
      className + " .dx-texteditor.dx-texteditor-empty.dx-widget.dx-textbox"
    ).getAttribute("title");
  } else {
    return false;
  }
}

/**
 * @desc - If you don't know how to grap an element without jquery, do it using this function
 * @param {String} query - Name of the element
 * @returns {*} - Whatever element/value in the DOM you are grapping
 */
function ssGetElementsFromJquery(query) {
  return $(query);
}

/**
 * @desc - If you don't know how to count a collection of elements without jquery, do it using this function
 * @param {String} query - If you don't know how to grap the number of elements without jquery, do it using this function
 * @returns {*} - Whatever length of element in the DOM you are grapping
 */
function ssGetElementsLengthFromJquery(query) {
  return $(query).length;
}

/******************** SETTER FUNCTIONS *************************/

/**
 * @desc - Hide an element
 * @param {STRING} - Name of the element
 */
function ssHide(name) {
  $(".mood-node-name-" + name).css("visibility", "hidden");
}

/**
 * @desc - Hides a menu item based on the name of the menu item, for example Data Quality. Is case sensitive
 * @param {STRING} - Name (text) of the menu item/tab
 */
function ssHideMenuItem(name) {
  var text = name;
  $("a")
    .filter(function () {
      return $(this).text() === text;
    })
    .hide();
}

/**
 * @desc - Display a hidden element
 * @param {STRING} - Name of the element
 */
function ssShow(name) {
  $(".mood-node-name-" + name).css("visibility", "visible");
}

/**
 * @desc - Click a button
 * @param {STRING} - Name of the button
 */
function ssClickButton(name) {
  if (!$(".mood-node-name-" + name).length > 0) return 0;
  $(".mood-node-name-" + name + " .mood-button").click();
  return 1;
}

/**
 * @desc - Set timeline arrows in front of everything else or push to back
 * @param {String} name - Name of the element
 * @param {Boolean} top - True sets it to top of the page, false sets it to bottom
 */
function ssTimelineArrowsOnTop(name, top) {
  if (top) {
    $(".mood-node-name-" + name + " .MooDOverlayContainer ").css(
      "z-index",
      "9999"
    );
  } else
    $(".mood-node-name-" + name + " .MooDOverlayContainer ").css(
      "z-index",
      "0"
    );
}

/**
 * @desc - Observe changes to the notification bar and excecute function in response
 * @param {String} searchFor - Insert description of how to find this parameter*
 * @param {Function} functionref - A reference to the function to excecute in response to changes to the notification bar
 */
function ssObserveNotificationBar(searchFor, functionref) {
  var ssNotificationBarObserver = new MutationObserver(function () {
    var text = $(".NotificationBar span").text().trim();
    var shown = $(".NotificationBar span").css("visibility") == "visible";
    if (shown && text.length > 4 && text == searchFor) {
      if (!wasShown) {
        functionref();
      }
      wasShown = 1;
    }

    if (wasShown && !shown) {
      wasShown = 0;
    }
  });

  if ($(".NotificationBar").length > 0)
    ssNotificationBarObserver.observe($(".NotificationBar")[0], {
      attributes: true,
      childList: false,
      subtree: true,
    });
}

/**
 * @desc - Set the value of a text editor element
 * @param {String} - name of the texteditor
 * @param {String} - value to set in the texteditor
 */
function ssSetTexteditorValue(name, val) {
  $(".mood-node-name-" + name + " input")[0].value = val;
  $(".mood-node-name-" + name + " input")[1].value = val;
}

/**
 * @desc - Set the dropdownvalue of a dropdown element
 * @param {String} - name of the dropdown
 * @param {String} - value to set in the dropdown
 */
function ssSetDropdownValue(name, val) {
  return ssSetTexteditorValue(name, val);
}

/**
 * @desc - Hide multiple elements
 * @param {Array} - Array of elements
 */
function ssHideMultipleElements(array) {
  array.forEach((element) => {
    element.style.visibility = "hidden";
  });
}

/**
 * @desc - Show multiple elements
 * @param {Array} - Array of elements
 */
function ssShowMultipleElements(array) {
  array.forEach((element) => {
    element.style.visibility = "visible";
  });
}

/**
 * @desc - Remove an element from the DOM. Use this if you want to be able to target the element in the DOM, but want it to be invisible and not take up space from other elements.
 * @param {String} - Name of the element
 */
function ssRemove(className) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className).style.display =
      "none";
  } else {
    return null;
  }
}

/**
 * @desc - Return an element you removed from the DOM.
 * @param {STRING} - Name of the element
 */
function ssCreate(className) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className).style.display =
      "block";
  } else {
    return null;
  }
}

/**
 * @desc - Destroy target element. It can't be regenerated.
 * @param {STRING} - Name of the element
 */
function ssKill(className) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className).remove();
  } else {
    return null;
  }
}

/**
 * @desc - Sets the innerText of an element (text visible to the user)
 * @param {String} - Name of the element
 */
function ssSetInnerText(className, innerText) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className).innerText =
      innerText;
  } else {
    return null;
  }
}

/**
 * @desc - Sets the textContent of an element, in case the element visible text is not displaayed as innerText (text visible to the user)
 * @param {String} - Name of the element
 */
function ssSetTextContent(className, innerText) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className).textContent =
      innerText;
  } else {
    return null;
  }
}

/**
 * @desc - Add an "explanation-text/tooltip" to an element, that will display when the cursor hover overs it
 * @param {String} - Name of the element
 * @param {String} - The text to be displayed. This can be a long text.
 * @param {String} - Top position in pixels example "0px" or "-150px" or "150px"
 * @param {String} - Left position in pixels example "0px" or "-150px" or "150px"
 */
function ssAddToolTip(className, toolTipText, top, left) {
  if (ssElementExists(className)) {
    if (ssGetElement(className).classList.contains("tooltip-parent") == false) {
      ssGetElement(className).classList.add("tooltip-parent");

      ssGetElement(className).innerHTML +=
        '<span class="tooltiptext ' +
        "tooltip-" +
        className +
        '">' +
        toolTipText +
        "</span>";
      var toolTipElement = ssGetNonMoodElement("tooltip-" + className);
      toolTipElement.style.top = top;
      toolTipElement.style.left = left;
    } else return null;
  }
}

/**
 * @desc - Disable an element
 * @param {String} className - The name of the element to disable
 */
function ssDisableElement(className) {
  if (ssElementExists(className)) {
    ssGetElement(className).style.opacity = 0.5;
    ssGetElement(className).style.pointerEvents = "none";
  } else {
    return null;
  }
}

/**
 * @desc - Enable an element that has been disabled
 * @param {String} className - The name of the element to disable
 */
function ssEnableElement(className) {
  if (ssElementExists(className)) {
    ssGetElement(className).style.opacity = 1;
    ssGetElement(className).style.pointerEvents = "";
  } else {
    return null;
  }
}

/**
 * @desc - Set the input value of a textfield
 * @param {String} className - The name of the element to disable
 * @param {String} className - The text to set the
 */
function ssSetValueAttribute(className, value) {
  if (ssElementExists(className)) {
    document.querySelector(".mood-node-name-" + className + " input").value =
      value;
  } else {
    return null;
  }
}

/**
 * @desc - Hide an element only in selected environments
 * @param {String} environmentURL - Part of the URL in where the element should be hidden
 * @param {String} className - The name of the element to hide
 */
function ssHideElementInEnvironment(environmentURL, className) {
  if (window.location.href.includes(environmentURL)) {
    document.querySelector(".mood-node-name-" + className).remove();
  } else {
    return null;
  }
}

/**
 * @desc - Make all linkable elements in a matricé open in a new tab. Note, the function can easily be rewritten to do something else to all cell's in a column, if the cell contain a symbol representing the elementtype, as this is what the function grabs on to.
 * @param {String} - The type ID of content in all cells in a column in this syntax (including ''): 'img[mood\\:id="270FB5C6E47940A5A31AD08732B0E0CB"]'
 */
function ssOpenColumnElementsInNewTab(typeIdOfColumnElement) {
  const columnSelectorForQuerySelector =
    'img[mood\\:id="' + typeIdOfColumnElement + '"]';
  const element = document.querySelectorAll(columnSelectorForQuerySelector);

  for (let i = 0; i < element.length; i++) {
    const parentElement = element[i].parentNode.parentNode;
    // Do something with the parent element, such as adding a class
    parentElement.classList.add("targeted-parent");
  }

  const targetParents = document.querySelectorAll(".targeted-parent");
  for (let i = 0; i < targetParents.length; i++) {
    const aTag = targetParents[i].querySelector("a");
    if (aTag) {
      aTag.setAttribute("target", "_blank");
    }
  }
}

/**
 * @desc - Add the default icon to a selected element in a dropdown.
 * @param {String} className - name of the dropdown
 */
function addIconToDropdown(className) {
  function handleClick() {
    ssGetElement(className + " img.icons").style.display = "block";
    ssGetElement(className + " img.icons").style.left = "360px";

    setTimeout(() => {
      ssGetElement(className + " img.icons").style.display = "block";
      ssGetElement(className + " img.icons").style.left = "360px";
    }, 1500);
  }

  function fireWhenDropdownClose() {
    ssGetElement(className).addEventListener("click", handleClick);
    ssGetElement(className).click();
  }
  fireWhenDropdownClose();
}

/**
 * @desc - Make a single clickable element that links to a Model Master open in a new tab.
 * @param {String} - The name of of the element
 */

function ssOpenLinkInNewTab(className) {
  document
    .querySelector(".mood-node-name-" + className + " a")
    .setAttribute("target", "_blank");
}

/**
 * @desc - Add a count (the result of a MooD query that counts elements) to a specific tab in a dropdown menu item.
 * @param {String} classNameCount - The name of of the element
 * @param {String} tabName - The name of parent tab, which hosts the subtab, you want to insert the count into
 * @param {String} innerTabName - The name of the child tab, you want to insert the count into
 */
function ssAddCountOfMyActions(classNameCount, tabName, innerTabName) {
  const numberOfMyActions = ssGetInnerText(classNameCount);
  let count = 0;
  if (numberOfMyActions > 0 && count == 0) {
    count++;

    const listelement = ssGetTab(tabName);

    function handleClick() {
      listelement.removeEventListener("click", handleClick);
      setTimeout(() => {
        const innerTab = ssGetTab(innerTabName);
        const linkElement = innerTab.querySelector("a");
        const numSpan = document.createElement("span");
        numSpan.textContent = numberOfMyActions;
        numSpan.style.marginLeft = "10px";
        numSpan.style.float = "right";
        linkElement.appendChild(numSpan);
      }, 500);
    }

    listelement.addEventListener("click", handleClick);
  }
}

/**
 * @desc - Due to difference in environments, this is a custom implementation of ssAddCountOfMyActions for IT Landscape. This implementation should be used if you are handling a menu with multiple tabs of the same name. Add a count (the result of a MooD query that counts elements) to a specific tab in a dropdown menu item.
 * @param {String} classNameCount - The name of of the element
 * @param {String} tabName - The name of parent tab, which hosts the subtab, you want to insert the count into
 * @param {String} innerTabName - The name of the child tab, you want to insert the count into
 * @param {Integer} tabIndex - The index of the tab saved in the array "listelement"
 * @param {Integer} innerTabIndex - The index of the innerTab saved in the array "innerTab"
 */
//prettier-ignore
function ssAddCountOfMyActionsItLandscape(classNameCount, tabName, innerTabName, tabIndex, innerTabIndex) {
  const numberOfMyActions = ssGetInnerText(classNameCount);
  let count = 0;
  if (numberOfMyActions > 0 && count == 0) {
    count++;

    const listelement = ssGetTabItLandscape(tabName)[tabIndex];

    function handleClick() {
      listelement.removeEventListener("click", handleClick);
      setTimeout(() => {
        const innerTab = ssGetTabItLandscape(innerTabName)[innerTabIndex];
        const linkElement = innerTab.querySelector("a");
        const numSpan = document.createElement("span");
        numSpan.textContent = numberOfMyActions;
        numSpan.style.marginLeft = "20px";
        numSpan.style.float = "right";
        linkElement.appendChild(numSpan);
      }, 250);
    }

    listelement.addEventListener("click", handleClick);
  }
}

/******************** MESSAGING FUNCTIONS *************************/

/**
 * @desc - Variable declarations for messaging functions
 */
var infoOutput = true; //Always true.
var errorOutput = true; //Always true.
var warnOutput = false; //Always set to false before production and in production environment.
var debugOutput = false; //Always set to false before production and in production environment.
var wasShown = 0; //Used for tracking the notification bar.

function ssWarn(message) {
  if (warnOutput) console.warn("[SS WARNING] " + message);
}

function ssError(message) {
  if (errorOutput) console.info("[SS ERROR] " + message);
}

function ssInfo(message) {
  if (infoOutput) console.info("[SS Info] " + message);
}

function ssDebug(message) {
  if (debugOutput) console.debug("[SS Debug] " + message);
}

/******************** HELPER FUNCTIONS *************************/

/**
 * @desc - Check if an element with text (eg. buttons) exists. This method handles errors in case you target an element that doesn't exist. Note that both this function and below ssElementExists are used by different clients.
 * @param {String} - Name of the element
 * @returns {Boolean} - If an element exists or not TRUE/FALSE
 */
function ssExists(name) {
  if ($(".mood-node-name-" + name) && $(".mood-node-name-" + name).length > 0)
    return $(".mood-node-name-" + name).length;
  return null;
}

/**
 * @desc - Check if an element exists. This method handles errors in case you target an element that doesn't exist.
 * @param {String} - Name of the element
 * @returns {Boolean} - If an element exists or not TRUE/FALSE
 */
function ssElementExists(className) {
  if (document.querySelector(".mood-node-name-" + className)) {
    return true;
  }
  return false;
}

/**
 * @desc - Check if a tab exists. This method handles errors in case you target a tab that doesn't exist.
 * @param {String} - Name of the element
 * @returns {Boolean} - If an element exists or not TRUE/FALSE
 */
function ssExistsTab(className) {
  if (
    Array.from(document.querySelectorAll("li")).find(
      (el) => el.textContent === className
    ).textContent == className
  ) {
    return true;
  }
  return false;
}

/**
 * @desc - Check if elements not generated by MooD exists. This method handles errors in case you target a tab that doesn't exist.
 * @param {String} - Name of the element
 * @returns {Boolean} - If an element exists or not TRUE/FALSE
 */
function ssNoneMoodElementExists(className) {
  if (document.querySelector("." + className)) {
    return true;
  }
  return false;
}
